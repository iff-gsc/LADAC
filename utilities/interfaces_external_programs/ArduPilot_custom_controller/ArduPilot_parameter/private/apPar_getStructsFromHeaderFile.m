function [structs, typedef_structs] = apPar_getStructsFromHeaderFile(file)
% APPAR_GETSTRUCTSFROMHEADERFILE performs a rudimentary parsing of a header
%   file generated by Simulink Coder for struct declarations.
%   Not suitable for general use!

% Disclaimer:
%   SPDX-License-Identifier: GPL-3.0-only
% 
%   Copyright (C) 2024 Jonas Withelm
%   Copyright (C) 2024 TU Braunschweig, Institute of Flight Guidance
% *************************************************************************

% open and read file
fid = fopen(file, 'r');
f = fread(fid, '*char')';

% create empty result structs
typedef_structs = struct;
%typedef_const_structs = struct;
structs = struct;



%% Search for global typedef structs
% - this detection requires that global
%   definitions do not have indentation. this is not required for
%   C++ syntax, therefore this is not the best way to do this!
[s_idxs, e_idxs] = regexp(f, '(?<=\n)typedef struct\s({.*?\n}|\w*) \w*;');

for idx1=1:numel(s_idxs)
    t = f(s_idxs(idx1):e_idxs(idx1));

    [parsed_cpp_tstruct, name] = parseCppTypedefStruct(t);
    typedef_structs.(name) = parsed_cpp_tstruct;
end



%% ToDo: Search for global typedef const structs
% [s_idxs, e_idxs] = regexp(f, '(?<=\n)typedef const struct \w*{.*?\n} \w*;');
% 
% for idx1=1:numel(s_idxs)
%     t = f(s_idxs(idx1):e_idxs(idx1));
%     
% end



%% Search for global structs
% - this detection requires no indentation, so it assumes that global
%   definitions do not have indentation. In fact this is not required for
%   C++ syntax, therefore this is not the best way to do this!
[s_idxs, e_idxs] = regexp(f, '(?<=\n)struct \w*\s{.*?\n};');

for idx1=1:numel(s_idxs)
    t = f(s_idxs(idx1):e_idxs(idx1));
    
    [parsed_cpp_struct, name] = parseCppStruct(t);
    structs.(name) = parsed_cpp_struct;
end

fclose(fid);

end





%% LOCAL FUNCTIONS
function out = rmCppSlComments(in)
%RMCPPSLCOMMENTS removes C++ single line comments
    
    [a,b] = regexp(in, ' *//.*?\n');
    
    for idx=numel(a):-1:1
        in(a(idx):b(idx)-1) = '';
    end
    
    % check if last line has comment
    [a,b] = regexp(in, ' *//.*?$');
    
    for idx=numel(a):-1:1
        in(a(idx):b(idx)) = '';
    end
    
    out = in;
    
end


function out = rmEmptyLines(in)
%RMEMPTYLINES removes empty lines (a line with only spaces or tabs is
%   also considered empty!)
    
    [a,b] = regexp(in, '\n(( *|\t)\n)+');
    
    for idx=numel(a):-1:1
        in(a(idx)+1:b(idx)) = '';
    end
    
    % check if first line is '\n'
    if in(1)==10
        out = in(2:end);
    else
        out = in;
    end
    
end


function out = rmLeadingSpaces(in)
%RMLEADINGSPACES removes leading spaces at the beginning of a string
    
    [a,b] = regexp(in, '^ *');
    
    if numel(a) > 1
        error('not implemented');
    end
    
    in(a:b) = '';
    
    out = in;
end


function [parsed_cpp_tstruct, name] = parseCppTypedefStruct(cpp_tstruct)
    
    % name of typedef struct
    name = regexp(cpp_tstruct, '\w*(?=;$)', 'match', 'once');
    
    % extract content of typedef struct
    idxs = find(cpp_tstruct==10);                       % find \n
    
    if isempty(idxs)
        var.type = regexp(cpp_tstruct, '(?<=^typedef struct )\w*', 'match', 'once');
        var.size = 1;
        parsed_cpp_tstruct = apPar_TypeDef(var.type, var.size);
    else
        content = cpp_tstruct(idxs(1)+1:idxs(end)-1);   % shorten
        parsed_cpp_tstruct = dismantleContent(content);
    end
    
end


function [parsed_cpp_struct, name] = parseCppStruct(cpp_struct)
    
    % name of struct
    name = regexp(cpp_struct, '(?<=^struct )\w*', 'match', 'once');
    
    % extract content of struct (remove first and last line)
    idxs = find(cpp_struct==10);                    % find \n
    content = cpp_struct(idxs(1)+1:idxs(end)-1);    % shorten
    
    parsed_cpp_struct = dismantleContent(content);
    
end


function dismantled_content = dismantleContent(content)
    
%     content = rmCppSlComments(content);
%     content = rmEmptyLines(content);
    
    [a,b] = regexp(content, '(struct\s{[^}]*} \w*;|\w* \*?\w*\[?[0-9]*\]?;)');
    if isempty(a)
        error(['When reading the code', newline, content, newline, ...
            'the data type and variable name could not be recognized. ', ...
            'The problem could possibly be solved by adjusting the expression ', ...
            'in the previously called regexp function.']);
    end
    
    dismantled_content = {};
    
    for idx = 1:numel(a)
        
        t2 = content(a(idx):b(idx));
        
        t2 = rmLeadingSpaces(t2);
        
        if contains(t2, 'struct {')
            var_name = regexp(t2, '(?<= )\w*(?=;$)', 'match', 'once');
            
            % extract content
            idxs = find(t2==10);                    % find \n
            content2 = t2(idxs(1)+1:idxs(end)-1);   % shorten
            
            var = dismantleContent(content2);
        else
            t3 = strsplit(t2, ' ');
            var_type = t3{1};
            var_name = regexp(t3{2}, '[a-zA-Z_][a-zA-Z0-9_]*', 'match', 'once');
            var_size = regexp(t3{2}, '(?<=\[)\d*(?=\])', 'match', 'once');
            if isempty(var_size)
                var_size = 1;
            else
                var_size = str2double(var_size);
            end
            
            var = apPar_TypeDef(var_type, var_size);
        end
        
        dismantled_content.(var_name) = var;
        
    end
end
